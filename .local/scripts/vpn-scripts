#!/bin/bash

set -euo pipefail

STATE_FILE="/tmp/vpn-scripts-state"

set_state() {
  echo "$1" > "$STATE_FILE"
}

get_state() {
  if [[ -f "$STATE_FILE" ]]; then
    cat "$STATE_FILE"
  else
    echo "disconnected"
  fi
}

# Verify if OpenVPN is actually connected by checking system state
verify_actual_connection() {
  # VPN interfaces have IPv4 addresses, system utun interfaces only have IPv6
  local utun_with_ipv4
  utun_with_ipv4=$(ifconfig 2>/dev/null | grep -B1 'inet [0-9]' | grep -E '^utun[0-9]+:' | head -1)
  if [[ -n "$utun_with_ipv4" ]]; then
    return 0
  fi

  # Only check IPv4 routes (ignore IPv6 which system utun interfaces use)
  local ipv4_utun_routes
  ipv4_utun_routes=$(netstat -rn -f inet 2>/dev/null | awk '{print $NF}' | grep -E '^utun[0-9]+$' | head -1)
  if [[ -n "$ipv4_utun_routes" ]]; then
    return 0
  fi

  # Check if default IPv4 route goes through utun (some VPNs do this)
  local default_route
  default_route=$(netstat -rn -f inet 2>/dev/null | awk '/^default|^0\.0\.0\.0/ {print $NF; exit}')
  if [[ -n "$default_route" ]] && [[ "$default_route" =~ ^utun[0-9]+$ ]]; then
    return 0
  fi

  return 1
}

get_status() {
  local stored_state
  stored_state=$(get_state)

  # If stored state is "connected", verify it's actually connected
  if [[ "$stored_state" == "connected" ]]; then
    if ! verify_actual_connection; then
      # State file says connected but actually disconnected - update it
      set_state "disconnected"
      echo "disconnected"
      return
    fi
  fi

  # If stored state is "disconnected", also verify (to catch manual connections)
  if [[ "$stored_state" == "disconnected" ]]; then
    if verify_actual_connection; then
      # State file says disconnected but actually connected - update it
      set_state "connected"
      echo "connected"
      return
    fi
  fi

  echo "$stored_state"
}

vpn_connect() {
  local code2fa
  code2fa="2457$(2fa 'mgc')"

  osascript -e 'tell application "System Events" to tell process "OpenVPN Connect" to tell menu bar item 1 of menu bar 2' \
    -e 'click' \
    -e 'get menu items of menu 1' \
    -e 'try
        click menu item "Connect" of menu 1
        do shell script "echo OpenVPN ready to connect"
      on error
        key code 53
        do shell script "echo Already connected"
      end try' \
    -e "delay 0.5
        set textBuffer to \"$code2fa\"
        repeat with i from 1 to count characters of textBuffer
          keystroke (character i of textBuffer)
          delay 0.05
        end repeat" \
    -e 'keystroke return' \
    -e 'end tell'

  # Wait a moment for connection to establish, then verify
  sleep 2
  if verify_actual_connection; then
    set_state "connected"
  else
    set_state "disconnected"
  fi
}

vpn_disconnect() {
  osascript -e 'tell application "System Events" to tell process "OpenVPN Connect" to tell menu bar item 1 of menu bar 2' \
    -e 'click' \
    -e 'get menu items of menu 1' \
    -e 'try
        click menu item "Disconnect" of menu 1
      on error
        key code 53
      end try' \
    -e 'end tell'

  # Wait a moment for disconnection, then verify
  sleep 1
  if ! verify_actual_connection; then
    set_state "disconnected"
  else
    set_state "connected"
  fi
}

show_usage() {
  cat << EOF
Usage: $0 [-c|-x|-s]
  -c  Connect to VPN
  -x  Disconnect from VPN
  -s  Check VPN status (verifies actual connection)
EOF
  exit 1
}

# Main execution
case "${1:-}" in
  -c)
    vpn_connect
    ;;
  -x)
    vpn_disconnect
    ;;
  -s)
    get_status
    ;;
  *)
    show_usage
    ;;
esac
